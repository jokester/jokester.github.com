<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>Android app 中 jsoup 性能原因的分析</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2017-02-23/jsoup-performance-for-android"/><link rel="preload" href="/_next/static/css/cbf8b5770f5f30aa7698.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbf8b5770f5f30aa7698.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-d42d109db6976c01a5e9.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" as="script"/><link rel="preload" href="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" as="script"/></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><p>最近在 android app 中用 <a href="https://jsoup.org/">jsoup</a> 从远程 html 中抽取数据, 觉得功能甚好, 只是有点慢. 翻了源码 &amp; 做了简单测试后觉得下面这几点可以改造一下:</p><ol><li>jsoup 的用法是先 <code>parse()</code> 创建一个完整的 <code>Document</code> 对象, 然后才能 <code>select()</code> 在里面找需要的 <code>Element</code>. 其实在抽取数据时可能只需要一个或几个 <code>Element</code>.</li><li><code>Element.select()</code> 好像一定会遍历整个 DOM 树, 我没有见到剪枝操作.</li><li>即使传入 <code>InputStream</code>, jsoup 也会先全部读入才开始 parse</li></ol><p>我想要的用法 (app 里是和 RxJava 一起用):</p><ol><li>用类似 SAX 的 API 一遍完成, 只为匹配到的部分 DOM (用 css selector 指定) 创建<code>Element</code>.
不过没有 DOM 难以实现所有的 css selector 语义, 所以我打算只支持适合 SAX 且简单的 selector. 完整的 selector 功能在创建好 <code>Element</code>后用已有的 <code>.select()</code> 做就可以了)</li><li>边解析边返回匹配到的<code>Element</code>, 尽早把第一批结果传给 UI.</li><li>边读 HTTP response 边解析</li></ol><hr/><p>2017-03-24 更新:</p><p>这个月尝试了一下, 发现完全 SAX 的做法性能上是满足需要的, 但和现实中的 HTML 的兼容性颇差.</p><p>现实中的 HTML 往往不规整, 最大的问题可能是 tag 不配对. 为了从不规整的 HTML 得到一个能用的 DOM 树, w3c 有一个十分复杂的标准算法: <a href="https://www.w3.org/TR/html51/syntax.html#parsing-html-documents">8.2 Parsing HTML documents</a>.</p><p>这个算法的很多地方实质上需要一个类似 DOM 树的东西. 即使能把这个算法改造成兼容 SAX 式 API, 维护 DOM 树的时间开销可能也不会有明显减少, 最多是可以边 parse 边丢弃, 不需要整个 DOM 树同时在内存.</p><p>而在我的需求中, (首个匹配的 DOM 元素前的) 延迟才是最重要的因素. 所以我打算换一个方向: 给 jsoup 已有的 DOM parser 加上能发射刚匹配到的 DOM 元素的 API.</p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2017/2017-02-23-jsoup-performance-for-android.md","slug":["2017-02-23","jsoup-performance-for-android"],"frontMatter":{"title":"Android app 中 jsoup 性能原因的分析","publishAt":"2017-02-23"}},"mdContent":"\n最近在 android app 中用 [jsoup](https://jsoup.org/) 从远程 html 中抽取数据, 觉得功能甚好, 只是有点慢. 翻了源码 \u0026 做了简单测试后觉得下面这几点可以改造一下:\n\n1. jsoup 的用法是先 `parse()` 创建一个完整的 `Document` 对象, 然后才能 `select()` 在里面找需要的 `Element`. 其实在抽取数据时可能只需要一个或几个 `Element`.\n2. `Element.select()` 好像一定会遍历整个 DOM 树, 我没有见到剪枝操作.\n3. 即使传入 `InputStream`, jsoup 也会先全部读入才开始 parse\n\n我想要的用法 (app 里是和 RxJava 一起用):\n\n1. 用类似 SAX 的 API 一遍完成, 只为匹配到的部分 DOM (用 css selector 指定) 创建`Element`.\n   不过没有 DOM 难以实现所有的 css selector 语义, 所以我打算只支持适合 SAX 且简单的 selector. 完整的 selector 功能在创建好 `Element`后用已有的 `.select()` 做就可以了)\n2. 边解析边返回匹配到的`Element`, 尽早把第一批结果传给 UI.\n3. 边读 HTTP response 边解析\n\n---\n\n2017-03-24 更新:\n\n这个月尝试了一下, 发现完全 SAX 的做法性能上是满足需要的, 但和现实中的 HTML 的兼容性颇差.\n\n现实中的 HTML 往往不规整, 最大的问题可能是 tag 不配对. 为了从不规整的 HTML 得到一个能用的 DOM 树, w3c 有一个十分复杂的标准算法: [8.2 Parsing HTML documents](https://www.w3.org/TR/html51/syntax.html#parsing-html-documents).\n\n这个算法的很多地方实质上需要一个类似 DOM 树的东西. 即使能把这个算法改造成兼容 SAX 式 API, 维护 DOM 树的时间开销可能也不会有明显减少, 最多是可以边 parse 边丢弃, 不需要整个 DOM 树同时在内存.\n\n而在我的需求中, (首个匹配的 DOM 元素前的) 延迟才是最重要的因素. 所以我打算换一个方向: 给 jsoup 已有的 DOM parser 加上能发射刚匹配到的 DOM 元素的 API.\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2017-02-23","jsoup-performance-for-android"]},"buildId":"HwBVD_-UnZn11yhGb2FbO","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["script",{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"}],["script",{"dangerouslySetInnerHTML":{"__html":"\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'UA-39627402-1', {\n              page_path: window.location.pathname,\n            });\n          "}}],["title",{"children":"Android app 中 jsoup 性能原因的分析"}],["meta",{"httpEquiv":"X-UA-Compatible","content":"IE=edge"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"}],["link",{"rel":"canonical","href":"https://jokester.github.io/posts/2017-02-23/jsoup-performance-for-android"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-555defa4e62ba07d4446.js"></script><script src="/_next/static/chunks/main-d42d109db6976c01a5e9.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" async=""></script><script src="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" async=""></script><script src="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" async=""></script><script src="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" async=""></script><script src="/_next/static/HwBVD_-UnZn11yhGb2FbO/_buildManifest.js" async=""></script><script src="/_next/static/HwBVD_-UnZn11yhGb2FbO/_ssgManifest.js" async=""></script></body></html>