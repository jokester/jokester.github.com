<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>TypeScript 2.1中的类型运算</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2016-12-21/typescript-2.1-type-calculation"/><link rel="preload" href="/_next/static/css/cbf8b5770f5f30aa7698.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbf8b5770f5f30aa7698.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-d42d109db6976c01a5e9.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" as="script"/><link rel="preload" href="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" as="script"/></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><p>去年 12 月的 TypeScript 2.1 中加入了 keyof / Lookup Types / Mapped Types 等 (编译期的) 类型运算特性。
本文将介绍这些特性，并用这些特性实现一个 &quot;递归的 Readonly&quot; 泛型。</p><ul><li>toc
{:toc}</li></ul><h2>新特性的介绍</h2><h3>keyof</h3><p><code>keyof T</code> 返回一个类型，这个类型是一个 string union，内容是 T 中所有的属性名 (key)。</p><p>例: <code>keyof { a: 1, b: 2 }</code> 得到的类型是 <code>&quot;a&quot; | &quot;b&quot;</code></p><h3>Lookup Types / 查找类型</h3><p><code>[]</code>的类型版。<code>T[K]</code> 返回 (类型 T 中以 K 为属性名的值) 的类型。K 必须是<code>keyof T</code>的子集，可以是一个字符串字面量。</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-typescript" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#96CBFE">const</span><span> a </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">,</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">&#x27;v2&#x27;</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// tv1 为number</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token" style="color:#FFFFB6;text-decoration:underline">tv1</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#96CBFE">typeof</span><span> a</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#A8FF60">&#x27;k1&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// tv2 为string</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token" style="color:#FFFFB6;text-decoration:underline">tv2</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#96CBFE">typeof</span><span> a</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#A8FF60">&#x27;k2&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// tv$ 为 (number|string): 属性名的并集对应到了属性值的类型的并集</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token" style="color:#FFFFB6;text-decoration:underline">tv$</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#96CBFE">typeof</span><span> a</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#A8FF60">&#x27;k1&#x27;</span><span> </span><span class="token" style="color:#EDEDED">|</span><span> </span><span class="token" style="color:#A8FF60">&#x27;k2&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// 以上的括号不是必需的: typeof优先级更高</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// 也可以用于获取内置类型 (string, 或string[]) 中的方法</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token" style="color:#FFFFB6;text-decoration:underline">t_charAt</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#A8FF60">&#x27;charAt&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// (pos: number) =&gt; string</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token" style="color:#FFFFB6;text-decoration:underline">t_push</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#A8FF60">&#x27;push&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// (...items: string[]) =&gt; number</span></code></pre><h3>Mapped Types / 映射类型</h3><p>我们可以在类型定义中引用其他类型的 (部分或全部) 属性，并对其进行运算，用运算结果定义出新的类型 (Mapped Type)。即&quot;把旧类型的属性 map/映射成新类型的属性&quot;，可以比作 list comprehension (把旧 list 的一部分 map 成新 list) 的类型属性版。</p><p>引用哪些属性是通过一个 string union 来定义的。这个 string union 必须是(keyof 旧类型)的子集，可以是 string 或 string union，也可以是 keyof 的返回值 (即映射全部属性)。</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#96CBFE">interface</span><span> </span><span class="token" style="color:#99CC99;text-decoration:underline">A</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>  k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>  k3</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// 从A中取一部分属性, 类型 ([A[P]) 不变</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">// 结果: type A_var1 = { k1: string, k3: number }</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">A_var1</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span> </span><span class="token" style="color:#96CBFE">in</span><span> </span><span class="token" style="color:#A8FF60">&#x27;k1&#x27;</span><span> </span><span class="token" style="color:#EDEDED">|</span><span> </span><span class="token" style="color:#A8FF60">&#x27;k3&#x27;</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#99CC99">A</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// 从A中取所有属性名, 类型改为number</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">// 结果: type A_var1 = { k1: number, k2: number, k3: number }</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">// 注意: keyof / Mapped type / 泛型一起使用时有一些特殊规则。建议读一下最后一部分 &quot;DeepReadonly 是怎样展开的&quot;</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">A_var2</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span> </span><span class="token" style="color:#96CBFE">in</span><span> </span><span class="token" style="color:#96CBFE">keyof</span><span> </span><span class="token" style="color:#99CC99">A</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#7C7C7C">// 从A中取所有属性, 类型改为相应的Promise (TS 2.1 release note中的Deferred是这个的泛型版)</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">A_var3</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span> </span><span class="token" style="color:#96CBFE">in</span><span> </span><span class="token" style="color:#96CBFE">keyof</span><span> </span><span class="token" style="color:#99CC99">A</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token known-class-name" style="color:#FFFFB6;text-decoration:underline">Promise</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#99CC99">A</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span></code></pre><h2>新特性的例子: Readonly</h2><p>使用上面介绍的新特性可以定义出一些实质是&quot;类型的 decorator&quot;的泛型，比如下面的 Readonly (已经在 TS2.1 标准库中):</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token doc-comment" style="color:#7C7C7C">/**
</span><span class="token doc-comment" style="color:#7C7C7C"> * Make all properties in T readonly
</span><span class="token doc-comment" style="color:#7C7C7C"> */</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">Readonly</span><span class="token" style="color:#EDEDED;text-decoration:underline">&lt;</span><span class="token" style="color:#99CC99;text-decoration:underline">T</span><span class="token" style="color:#EDEDED;text-decoration:underline">&gt;</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#96CBFE">readonly</span><span> </span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span> </span><span class="token" style="color:#96CBFE">in</span><span> </span><span class="token" style="color:#96CBFE">keyof</span><span> </span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#96CBFE">interface</span><span> </span><span class="token" style="color:#99CC99;text-decoration:underline">A</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>  k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">string</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>  k3</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span>
</span>
<span></span><span class="token doc-comment" style="color:#7C7C7C">/**
</span><span class="token doc-comment" style="color:#7C7C7C"> 等价于
</span><span class="token doc-comment" style="color:#7C7C7C">type A_ro = </span><span class="token doc-comment" style="color:#c5c8c6">{</span><span class="token doc-comment" style="color:#7C7C7C">
</span><span class="token doc-comment" style="color:#7C7C7C">    readonly k1: string;
</span><span class="token doc-comment" style="color:#7C7C7C">    readonly k2: string;
</span><span class="token doc-comment" style="color:#7C7C7C">    readonly k3: number;
</span><span class="token doc-comment" style="color:#7C7C7C"></span><span class="token doc-comment" style="color:#c5c8c6">}</span><span class="token doc-comment" style="color:#7C7C7C">
</span><span class="token doc-comment" style="color:#7C7C7C"> */</span><span>
</span><span></span><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">A_ro</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token maybe-class-name">Readonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#99CC99">A</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span></code></pre><p>利用这些类型运算，我们可以表达出更复杂的编译期约束，十分适合 (需要和无限的类型一起工作的) 的代码或库。比如 Release note 里还提到的<code>Partial</code> / <code>Pick</code> / <code>Record</code> 等类型。</p><h2>Readonly 的强化版: DeepReadonly</h2><p>前面提到的<code>Readonly</code>只保证属性只读，不会把属性的属性也变成只读:</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#96CBFE">const</span><span> v </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">,</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span> k21</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#FF73FD">2</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#96CBFE">const</span><span> v_ro </span><span class="token" style="color:#EDEDED">=</span><span> v </span><span class="token" style="color:#96CBFE">as</span><span> </span><span class="token maybe-class-name">Readonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#96CBFE">typeof</span><span> v</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>v_ro</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k1</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#FF73FD">2</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// 禁止</span><span>
</span><span>v_ro</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k2</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k21</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#FF73FD">3</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// 可以</span></code></pre><p>我们可以写一个 DeepReadonly，实现递归的只读:</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#96CBFE">type</span><span> </span><span class="token maybe-class-name" style="color:#FFFFB6;text-decoration:underline">DeepReadonly</span><span class="token" style="color:#EDEDED;text-decoration:underline">&lt;</span><span class="token" style="color:#99CC99;text-decoration:underline">T</span><span class="token" style="color:#EDEDED;text-decoration:underline">&gt;</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#96CBFE">readonly</span><span> </span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span> </span><span class="token" style="color:#96CBFE">in</span><span> </span><span class="token" style="color:#96CBFE">keyof</span><span> </span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#c5c8c6">[</span><span class="token" style="color:#99CC99">P</span><span class="token" style="color:#c5c8c6">]</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#c5c8c6">;</span><span>
</span>
<span></span><span class="token" style="color:#96CBFE">function</span><span> </span><span class="token generic-function" style="color:#DAD085">deepFreeze</span><span class="token generic-function generic" style="color:#EDEDED;text-decoration:underline">&lt;</span><span class="token generic-function generic" style="color:#99CC99;text-decoration:underline">T</span><span class="token generic-function generic" style="color:#EDEDED;text-decoration:underline">&gt;</span><span class="token" style="color:#c5c8c6">(</span><span>val</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>  </span><span class="token" style="color:#96CBFE">return</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span>val </span><span class="token" style="color:#96CBFE">as</span><span> </span><span class="token" style="color:#A8FF60">any</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#96CBFE">as</span><span> </span><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#99CC99">T</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span><span>
</span>
<span></span><span class="token" style="color:#96CBFE">const</span><span> v_deep_ro </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span>v </span><span class="token" style="color:#96CBFE">as</span><span> </span><span class="token" style="color:#A8FF60">any</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#96CBFE">as</span><span> </span><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#96CBFE">typeof</span><span> v</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>v_deep_ro</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k1</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#FF73FD">2</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// 禁止</span><span>
</span><span>v_deep_ro</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k2</span><span class="token" style="color:#c5c8c6">.</span><span class="token property-access">k21</span><span> </span><span class="token" style="color:#EDEDED">=</span><span> </span><span class="token" style="color:#FF73FD">3</span><span class="token" style="color:#c5c8c6">;</span><span> </span><span class="token" style="color:#7C7C7C">// **也禁止**</span></code></pre><h2>DeepReadonly 是怎样展开的</h2><p>(这个话题是 @vilicvane 帮我审稿时提到的。我又翻了一下相关的 issue 后觉得满有意思.. 就一起加进来了。不读这个在大多数情况下应该不影响使用)</p><p>背景: 如果 A 是泛型的类型参数(比如<code>T&lt;A&gt;</code>)，则称形如 <code>{ [P in keyof A]: (类型) }</code> 的映射类型为 A 的同构 (isomorphic) 类型 (含有和 A 相同的属性名，即相同的&quot;形状&quot;) 。在展开<code>T&lt;A&gt;</code>时有如下附加规则:</p><ol><li>基本类型(<code>string | number | boolean | undefined | null</code>)的同构类型强行定义为其本身，即跳过了对值类型的运算</li><li>union 类型，如<code>type A = A1 | A2</code>，的同构类型 <code>T&lt;A&gt;</code> 展开为 <code>T&lt;A1&gt; | T&lt;A2&gt;</code></li></ol><p>所以上面的<code>DeepReadonly&lt;typeof v&gt;</code>的 (概念上) 展开过程是这样的 :</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#c5c8c6">{</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span> k21</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#EDEDED">&gt;</span></code></pre><p>↓</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#c5c8c6">{</span><span> k21</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span> </span><span class="token" style="color:#c5c8c6">}</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span></code></pre><p>↓</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>        </span><span class="token" style="color:#96CBFE">readonly</span><span> k21</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token maybe-class-name">DeepReadonly</span><span class="token" style="color:#EDEDED">&lt;</span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#EDEDED">&gt;</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>    </span><span class="token" style="color:#c5c8c6">}</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span></code></pre><p>↓ (规则 1)</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-ts" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k1</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>    </span><span class="token" style="color:#96CBFE">readonly</span><span> k2</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#c5c8c6">{</span><span>
</span><span>        </span><span class="token" style="color:#96CBFE">readonly</span><span> k21</span><span class="token" style="color:#EDEDED">:</span><span> </span><span class="token" style="color:#A8FF60">number</span><span class="token" style="color:#c5c8c6">;</span><span>
</span><span>    </span><span class="token" style="color:#c5c8c6">}</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">}</span></code></pre><p>(规则 1 有时会导致一些奇怪的结果，不过大多数情况下我们不是想要基本类型的同构类型，到此停止展开可以接受)</p></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/2016/2016-12-21-typescript-2.1-type-calculation.md","slug":["2016-12-21","typescript-2.1-type-calculation"],"frontMatter":{"title":"TypeScript 2.1中的类型运算","publishAt":"2016-12-21"}},"mdContent":"\n去年 12 月的 TypeScript 2.1 中加入了 keyof / Lookup Types / Mapped Types 等 (编译期的) 类型运算特性。\n本文将介绍这些特性，并用这些特性实现一个 \"递归的 Readonly\" 泛型。\n\n- toc\n  {:toc}\n\n## 新特性的介绍\n\n### keyof\n\n`keyof T` 返回一个类型，这个类型是一个 string union，内容是 T 中所有的属性名 (key)。\n\n例: `keyof { a: 1, b: 2 }` 得到的类型是 `\"a\" | \"b\"`\n\n### Lookup Types / 查找类型\n\n`[]`的类型版。`T[K]` 返回 (类型 T 中以 K 为属性名的值) 的类型。K 必须是`keyof T`的子集，可以是一个字符串字面量。\n\n```typescript\nconst a = { k1: 1, k2: 'v2' };\n\n// tv1 为number\ntype tv1 = typeof a['k1'];\n\n// tv2 为string\ntype tv2 = typeof a['k2'];\n\n// tv$ 为 (number|string): 属性名的并集对应到了属性值的类型的并集\ntype tv$ = typeof a['k1' | 'k2'];\n\n// 以上的括号不是必需的: typeof优先级更高\n\n// 也可以用于获取内置类型 (string, 或string[]) 中的方法\ntype t_charAt = string['charAt']; // (pos: number) =\u003e string\ntype t_push = string[]['push']; // (...items: string[]) =\u003e number\n```\n\n### Mapped Types / 映射类型\n\n我们可以在类型定义中引用其他类型的 (部分或全部) 属性，并对其进行运算，用运算结果定义出新的类型 (Mapped Type)。即\"把旧类型的属性 map/映射成新类型的属性\"，可以比作 list comprehension (把旧 list 的一部分 map 成新 list) 的类型属性版。\n\n引用哪些属性是通过一个 string union 来定义的。这个 string union 必须是(keyof 旧类型)的子集，可以是 string 或 string union，也可以是 keyof 的返回值 (即映射全部属性)。\n\n```ts\ninterface A {\n  k1: string;\n  k2: string;\n  k3: number;\n}\n\n// 从A中取一部分属性, 类型 ([A[P]) 不变\n// 结果: type A_var1 = { k1: string, k3: number }\ntype A_var1 = {\n  [P in 'k1' | 'k3']: A[P];\n};\n\n// 从A中取所有属性名, 类型改为number\n// 结果: type A_var1 = { k1: number, k2: number, k3: number }\n// 注意: keyof / Mapped type / 泛型一起使用时有一些特殊规则。建议读一下最后一部分 \"DeepReadonly 是怎样展开的\"\ntype A_var2 = {\n  [P in keyof A]: number;\n};\n\n// 从A中取所有属性, 类型改为相应的Promise (TS 2.1 release note中的Deferred是这个的泛型版)\ntype A_var3 = {\n  [P in keyof A]: Promise\u003cA[P]\u003e;\n};\n```\n\n## 新特性的例子: Readonly\n\n使用上面介绍的新特性可以定义出一些实质是\"类型的 decorator\"的泛型，比如下面的 Readonly (已经在 TS2.1 标准库中):\n\n```ts\n/**\n * Make all properties in T readonly\n */\ntype Readonly\u003cT\u003e = {\n  readonly [P in keyof T]: T[P];\n};\n\ninterface A {\n  k1: string;\n  k2: string;\n  k3: number;\n}\n\n/**\n 等价于\ntype A_ro = {\n    readonly k1: string;\n    readonly k2: string;\n    readonly k3: number;\n}\n */\ntype A_ro = Readonly\u003cA\u003e;\n```\n\n利用这些类型运算，我们可以表达出更复杂的编译期约束，十分适合 (需要和无限的类型一起工作的) 的代码或库。比如 Release note 里还提到的`Partial` / `Pick` / `Record` 等类型。\n\n## Readonly 的强化版: DeepReadonly\n\n前面提到的`Readonly`只保证属性只读，不会把属性的属性也变成只读:\n\n```ts\nconst v = { k1: 1, k2: { k21: 2 } };\n\nconst v_ro = v as Readonly\u003ctypeof v\u003e;\nv_ro.k1 = 2; // 禁止\nv_ro.k2.k21 = 3; // 可以\n```\n\n我们可以写一个 DeepReadonly，实现递归的只读:\n\n```ts\ntype DeepReadonly\u003cT\u003e = {\n  readonly [P in keyof T]: DeepReadonly\u003cT[P]\u003e;\n};\n\nfunction deepFreeze\u003cT\u003e(val: T) {\n  return (val as any) as DeepReadonly\u003cT\u003e;\n}\n\nconst v_deep_ro = (v as any) as DeepReadonly\u003ctypeof v\u003e;\nv_deep_ro.k1 = 2; // 禁止\nv_deep_ro.k2.k21 = 3; // **也禁止**\n```\n\n## DeepReadonly 是怎样展开的\n\n(这个话题是 @vilicvane 帮我审稿时提到的。我又翻了一下相关的 issue 后觉得满有意思.. 就一起加进来了。不读这个在大多数情况下应该不影响使用)\n\n背景: 如果 A 是泛型的类型参数(比如`T\u003cA\u003e`)，则称形如 `{ [P in keyof A]: (类型) }` 的映射类型为 A 的同构 (isomorphic) 类型 (含有和 A 相同的属性名，即相同的\"形状\") 。在展开`T\u003cA\u003e`时有如下附加规则:\n\n1. 基本类型(`string | number | boolean | undefined | null`)的同构类型强行定义为其本身，即跳过了对值类型的运算\n2. union 类型，如`type A = A1 | A2`，的同构类型 `T\u003cA\u003e` 展开为 `T\u003cA1\u003e | T\u003cA2\u003e`\n\n所以上面的`DeepReadonly\u003ctypeof v\u003e`的 (概念上) 展开过程是这样的 :\n\n```ts\nDeepReadonly\u003c{ k1: number; k2: { k21: number } }\u003e\n```\n\n↓\n\n```ts\n{\n    readonly k1: number;\n    readonly k2: DeepReadonly\u003c{ k21: number }\u003e;\n}\n```\n\n↓\n\n```ts\n{\n    readonly k1: number;\n    readonly k2: {\n        readonly k21: DeepReadonly\u003cnumber\u003e;\n    }\n}\n```\n\n↓ (规则 1)\n\n```ts\n{\n    readonly k1: number;\n    readonly k2: {\n        readonly k21: number;\n    }\n}\n```\n\n(规则 1 有时会导致一些奇怪的结果，不过大多数情况下我们不是想要基本类型的同构类型，到此停止展开可以接受)\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2016-12-21","typescript-2.1-type-calculation"]},"buildId":"tlxtjnvNyuDsinQss6fzz","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["script",{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"}],["script",{"dangerouslySetInnerHTML":{"__html":"\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'UA-39627402-1', {\n              page_path: window.location.pathname,\n            });\n          "}}],["title",{"children":"TypeScript 2.1中的类型运算"}],["meta",{"httpEquiv":"X-UA-Compatible","content":"IE=edge"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"}],["link",{"rel":"canonical","href":"https://jokester.github.io/posts/2016-12-21/typescript-2.1-type-calculation"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-555defa4e62ba07d4446.js"></script><script src="/_next/static/chunks/main-d42d109db6976c01a5e9.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" async=""></script><script src="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" async=""></script><script src="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" async=""></script><script src="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" async=""></script><script src="/_next/static/tlxtjnvNyuDsinQss6fzz/_buildManifest.js" async=""></script><script src="/_next/static/tlxtjnvNyuDsinQss6fzz/_ssgManifest.js" async=""></script></body></html>