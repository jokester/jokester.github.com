<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-39627402-1', {
              page_path: window.location.pathname,
            });
          </script><title>Note for SICP Chapter 2</title><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"/><link rel="canonical" href="https://jokester.github.io/posts/2014-05-19/sicp-chapter-2"/><link rel="preload" href="/_next/static/css/cbf8b5770f5f30aa7698.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbf8b5770f5f30aa7698.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-d42d109db6976c01a5e9.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" as="script"/><link rel="preload" href="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" as="script"/></head><body class="overflow-y-scroll"><div id="__next"><div class="bg-black text-yellow-100"><div class="min-h-screen container mx-auto"><div class="px-4 py-1 flex items-center bg-gray-900 space-x-4 text-sm"><a class="sm:hidden text-lg" href="/">挖坑自動機</a><a class="hidden sm:inline-block text-lg" href="/">挖坑自動機 / Digging automaton</a><span>|</span><a class="text-yellow-200" href="/posts/">/posts</a><a class="" href="/works/">/works</a><a class="" href="/about/">/about</a></div><div class="px-4 pt-6"><div class="markdown"><h1></h1><hr/><div class="markdown"><ul><li>toc
{:toc}</li></ul><h4>Building Abstractions with Data</h4><h5>Introduction to Data Abstraction</h5><h6>Example: Arithmetic Operations for Rational Numbers</h6><ul><li><p><code>cons</code> forges a pair. <code>car</code>, <code>cdr</code> takes value out of a pair.</p><ul><li>example: <code>(car (cons a b)) ; =&gt;a</code>, <code>(cdr (cons a b)) ; =&gt;b</code>.</li></ul></li><li><p>list is but a special form of pair</p><ul><li><code>&#x27;()</code> or <code>nil</code> is a list<ul><li><code>nil</code> is not available in MIT-scheme.</li></ul></li><li>The return value of <code>(cons something &lt;a-list&gt;)</code> is also a list</li><li><code>(list a1 a2 ... an)</code> is short for <code>(cons a1 (cons a2 ... (cons an nil) ... ))</code></li><li>In the other direction, a pair is an improper list</li></ul></li></ul><h6>Abstraction Barriers</h6><h6>What Is Meant by Data?</h6><ul><li>&quot;the ability to manipulate procedures as objects automatically provides the ability to represent compound data.&quot;</li></ul><h6>Extended Exercise: Interval Arithmetic</h6><h5>Hierarchical Data and the Closure Property</h5><h6>Representing Sequences</h6><ul><li><p><code>(cons something a-list)</code> yields another list.</p></li><li><p><code>(append list1 list2)</code> returns concatenation of list1 and list2.</p></li><li><p>dotted-tail notation: <code>(define (foo arg1 arg2 . rest ) &lt;body&gt;)</code></p><ul><li>arg1, arg2 capture the first 2 arguments, rest captures the rest.</li></ul></li></ul><h6>Hierarchical Structures</h6><ul><li><p><code>(cons (list 1 2) (list 3 4))</code> denotes a tree.</p></li><li><p>Exercise 2.27: a deep-reverse procedure</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (deep-reverse arg)
</span>  (if (list? arg)
<!-- -->    (reverse (map deep-reverse a-list))
<!-- -->    arg))
<!-- -->(deep-reverse &#x27;(1 (2 3) (4 (5 6)))) ; =&gt;
</code></pre></li><li><p>Exercise 2.28: flattening a tree (nested list) in left-right order</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (fringe arg)
</span>  (if (list? arg)
<!-- -->    (apply append (map fringe arg))
<!-- -->    (list arg)))
<!-- -->(display (fringe (list 1 (list 2) (list 3 4 (list 5)) 6)))
<!-- -->; =&gt; (1 2 3 4 5 6)
</code></pre></li><li><p>Exercise 2.31: a tree-map procedure</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (map-tree proc arg)
</span>  (if (list? arg)
<!-- -->    (map (lambda (x) (map-tree proc x)) arg)
<!-- -->    (proc arg)))
<!-- -->(define (square x) (* x x))
<!-- -->(display
<!-- -->  (map-tree
<!-- -->    square
<!-- -->    &#x27;(1 2 (3 4 (5)))) )
<!-- -->; =&gt; (1 4 (9 16 (25)))
</code></pre></li></ul><h6>Sequences as Conventional Interfaces</h6><ul><li>&quot;basic&quot; operations on a bunch of things:<ul><li><p>enumerate: transform something into a list</p></li><li><p>filter: select from a list</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(filter precidate a-list) ; =&gt;list</span></code></pre></li><li><p>map: transform the list via a proc</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(map proc a-list) ; =&gt;list</span></code></pre></li><li><p>accumulate: fold a list of things, a.k.a &quot;fold-right&quot;</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (accumulate op init a-list)
</span>  (if (null? a-list)
<!-- -->    init
<!-- -->    (op (car a-list)
<!-- -->        (accumulate op init (cdr a-list)))))
<!-- -->;
<!-- -->;       op
<!-- -->;      /  \
<!-- -->;    car   op
<!-- -->;         /  \
<!-- -->;       cadr ...
<!-- -->;               \
<!-- -->;                op
<!-- -->;               /  \
<!-- -->;            last  init  ; init is to the &quot;RIGHT&quot; of l
</code></pre></li><li><p>Use of the preceding &quot;basic&quot; operations encourage modular design</p><ul><li>Because one have to fit to the known-to-be-common-enough interfaces</li></ul></li><li><p>filter and map can be implemented using accumulate</p></li><li><p>Exercise 2.33: implement <code>map</code>, <code>append</code>, <code>my-length</code> with accumulate</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (my-map proc sequence)
</span>  (accumulate
<!-- -->    (lambda (head acc) (cons (proc head) acc))
<!-- -->    &#x27;()
<!-- -->    sequence))
<!-- -->(define (my-append seq1 seq2)
<!-- -->  (accumulate
<!-- -->    (lambda (head acc) (cons head acc))
<!-- -->    seq2
<!-- -->    seq1))
<!-- -->(define (my-length sequence)
<!-- -->  (accumulate
<!-- -->    (lambda (head acc) (+ 1 acc))
<!-- -->    0
<!-- -->    sequence))
</code></pre></li><li><p>Exercise 2.36: implement <code>accumulate-n</code> with <code>accumulate</code></p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (accumulate-n op init seqs)
</span>  (if (null? (car seqs))
<!-- -->        &#x27;()
<!-- -->        (cons (accumulate op init (map car seqs))
<!-- -->              (accumulate-n op init (map cdr seqs)))))
<!-- -->(accumulate-n
<!-- -->  +
<!-- -->  0
<!-- -->  &#x27;((1  2  3)
<!-- -->    (4  5  6)
<!-- -->    (7  8  9)
<!-- -->    (10 11 12))) ; =&gt; &#x27;(22 26 30)
</code></pre></li><li><p>Exercise 2.38: fold-left</p><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span>(define (my-fold-left op init sequence)
</span>  (if (null? sequence)
<!-- -->    init
<!-- -->    (my-fold-left
<!-- -->      op
<!-- -->      (op init (car sequence))
<!-- -->      (cdr sequence))))
<!-- -->;                        op
<!-- -->;                       /  \
<!-- -->;                    ...   last
<!-- -->;                    /
<!-- -->;                  op
<!-- -->;                 /  \
<!-- -->;               op   cadr
<!-- -->;              /  \
<!-- -->; &quot;LEFT&quot;: initial  car
</code></pre><ul><li>a sufficient condition: when binary operator <code>op</code> satisfies <code>op(a,b) 三 op(b,a)</code></li></ul></li><li><p>Exercise 2.40: unique-pairs</p></li><li><p>Exercise 2.41: eight-queens puzzle</p></li></ul></li></ul><h6>Example: A Picture Language</h6><h5>Symbolic Data</h5><h6>Quotation</h6><ul><li><p><code>&#x27;a</code> returns a symbol: <code>a</code></p></li><li><p><code>&#x27;(a b)</code> evaluates to the list of symbol: <code>(a b)</code></p></li><li><p>Extra: <code>`( )</code> quotes a list where only specific members are evaluated (&quot;quasiquote&quot;). <code>,</code> specifies the evaluated number in such a list.</p><ul><li>Example: <code>(let ((a 1)) `(a ,a))</code> evals to <code>(a 1)</code>.</li></ul></li><li><p><code>(eq? a b)</code> returns whether symbol a and b are the same.</p></li></ul><h6>Example: Symbolic Differentiation</h6><h6>Example: Representing Sets</h6><ul><li><p><strong>Sets</strong> are defined by operations on them, i.e. the interface of Set class.</p><ul><li><code>(adjoin-set elem set)</code></li><li><code>(element-of-set? elem set)</code></li><li><code>(intersection-set set1 set2)</code></li><li><code>(union-set set1 set2)</code></li></ul></li><li><p>Underlying implementation can vary:</p><ul><li>unordered lists</li><li>ordered lists</li><li>binary trees</li></ul></li></ul><h6>Example: Huffman Encoding Trees</h6><ul><li>prefix code: no complete code (a sequence of bits) is an prefix of another code<ul><li>code automatically get segmented: we can immediately obtain a code when its last bit is received</li><li>no need to look forward, because it is the only legal way to decode the symbols</li></ul></li></ul><pre style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em;background:#1d1f21"><code class="language-scheme" style="color:#c5c8c6;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#96CBFE">define</span><span> sorted-codes
</span><span>  </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">fastsort</span><span>
</span><span>    </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">huffman-encode</span><span>
</span><span>                </span><span class="token" style="color:#c5c8c6">&#x27;</span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">a</span><span> </span><span class="token" style="color:#FF73FD">8</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">b</span><span> </span><span class="token" style="color:#FF73FD">3</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">c</span><span> </span><span class="token" style="color:#FF73FD">4</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span>                  </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">d</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">e</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">f</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span>                  </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">g</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">h</span><span> </span><span class="token" style="color:#FF73FD">1</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">i</span><span> </span><span class="token" style="color:#FF73FD">9</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span>                  </span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span>    </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">sort-by</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#96CBFE">lambda</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token lambda-parameter">x</span><span class="token" style="color:#c5c8c6">)</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#EDEDED">-</span><span> </span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#DAD085">caddr</span><span> x</span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span></span><span class="token" style="color:#c5c8c6">(</span><span class="token" style="color:#A8FF60">map</span><span> display-code sorted-codes</span><span class="token" style="color:#c5c8c6">)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = i      count = 9       code = (0 0)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = a      count = 8       code = (0 1)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = c      count = 4       code = (0 1 0)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = b      count = 3       code = (0 1 1)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = d      count = 1       code = (1 1 1 1)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = e      count = 1       code = (1 1 1 0)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = h      count = 1       code = (0 1 1 1)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = f      count = 1       code = (0 1 1 0 1)</span><span>
</span><span></span><span class="token" style="color:#7C7C7C">; symbol = g      count = 1       code = (0 1 1 0 0)</span></code></pre></div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdMeta":{"realpath":"/home/runner/work/jokester.github.io/jokester.github.io/posts/series/sicp/2014-05-19-sicp-chapter-2.markdown","slug":["2014-05-19","sicp-chapter-2"],"frontMatter":{"title":"Note for SICP Chapter 2","publishAt":"2014-05-19"}},"mdContent":"\n* toc\n{:toc}\n\n#### Building Abstractions with Data\n\n##### Introduction to Data Abstraction\n\n###### Example: Arithmetic Operations for Rational Numbers\n\n- `cons` forges a pair. `car`, `cdr` takes value out of a pair.\n    - example: `(car (cons a b)) ; =\u003ea`, `(cdr (cons a b)) ; =\u003eb`.\n\n- list is but a special form of pair\n    - `'()` or `nil` is a list\n        - `nil` is not available in MIT-scheme.\n    - The return value of `(cons something \u003ca-list\u003e)` is also a list\n    - `(list a1 a2 ... an)` is short for `(cons a1 (cons a2 ... (cons an nil) ... ))`\n    - In the other direction, a pair is an improper list\n\n###### Abstraction Barriers\n\n###### What Is Meant by Data?\n\n- \"the ability to manipulate procedures as objects automatically provides the ability to represent compound data.\"\n\n###### Extended Exercise: Interval Arithmetic\n\n##### Hierarchical Data and the Closure Property\n\n###### Representing Sequences\n\n- `(cons something a-list)` yields another list.\n\n- `(append list1 list2)` returns concatenation of list1 and list2.\n\n- dotted-tail notation: `(define (foo arg1 arg2 . rest ) \u003cbody\u003e)`\n    - arg1, arg2 capture the first 2 arguments, rest captures the rest.\n\n###### Hierarchical Structures\n\n- `(cons (list 1 2) (list 3 4))` denotes a tree.\n\n- Exercise 2.27: a deep-reverse procedure\n\n      (define (deep-reverse arg)\n        (if (list? arg)\n          (reverse (map deep-reverse a-list))\n          arg))\n      (deep-reverse '(1 (2 3) (4 (5 6)))) ; =\u003e\n\n- Exercise 2.28: flattening a tree (nested list) in left-right order\n\n      (define (fringe arg)\n        (if (list? arg)\n          (apply append (map fringe arg))\n          (list arg)))\n      (display (fringe (list 1 (list 2) (list 3 4 (list 5)) 6)))\n      ; =\u003e (1 2 3 4 5 6)\n\n- Exercise 2.31: a tree-map procedure\n\n      (define (map-tree proc arg)\n        (if (list? arg)\n          (map (lambda (x) (map-tree proc x)) arg)\n          (proc arg)))\n      (define (square x) (* x x))\n      (display\n        (map-tree\n          square\n          '(1 2 (3 4 (5)))) )\n      ; =\u003e (1 4 (9 16 (25)))\n\n###### Sequences as Conventional Interfaces\n\n- \"basic\" operations on a bunch of things:\n    - enumerate: transform something into a list\n\n    - filter: select from a list\n\n          (filter precidate a-list) ; =\u003elist\n\n    - map: transform the list via a proc\n\n          (map proc a-list) ; =\u003elist\n\n    - accumulate: fold a list of things, a.k.a \"fold-right\"\n\n          (define (accumulate op init a-list)\n            (if (null? a-list)\n              init\n              (op (car a-list)\n                  (accumulate op init (cdr a-list)))))\n          ;\n          ;       op\n          ;      /  \\\n          ;    car   op\n          ;         /  \\\n          ;       cadr ...\n          ;               \\\n          ;                op\n          ;               /  \\\n          ;            last  init  ; init is to the \"RIGHT\" of l\n\n    - Use of the preceding \"basic\" operations encourage modular design\n        - Because one have to fit to the known-to-be-common-enough interfaces\n\n    - filter and map can be implemented using accumulate\n\n    - Exercise 2.33: implement `map`, `append`, `my-length` with accumulate\n\n          (define (my-map proc sequence)\n            (accumulate\n              (lambda (head acc) (cons (proc head) acc))\n              '()\n              sequence))\n          (define (my-append seq1 seq2)\n            (accumulate\n              (lambda (head acc) (cons head acc))\n              seq2\n              seq1))\n          (define (my-length sequence)\n            (accumulate\n              (lambda (head acc) (+ 1 acc))\n              0\n              sequence))\n\n    - Exercise 2.36: implement `accumulate-n` with `accumulate`\n\n          (define (accumulate-n op init seqs)\n            (if (null? (car seqs))\n                  '()\n                  (cons (accumulate op init (map car seqs))\n                        (accumulate-n op init (map cdr seqs)))))\n          (accumulate-n\n            +\n            0\n            '((1  2  3)\n              (4  5  6)\n              (7  8  9)\n              (10 11 12))) ; =\u003e '(22 26 30)\n\n    - Exercise 2.38: fold-left\n\n          (define (my-fold-left op init sequence)\n            (if (null? sequence)\n              init\n              (my-fold-left\n                op\n                (op init (car sequence))\n                (cdr sequence))))\n          ;                        op\n          ;                       /  \\\n          ;                    ...   last\n          ;                    /\n          ;                  op\n          ;                 /  \\\n          ;               op   cadr\n          ;              /  \\\n          ; \"LEFT\": initial  car\n\n        - a sufficient condition: when binary operator `op` satisfies `op(a,b) 三 op(b,a)`\n\n    - Exercise 2.40: unique-pairs\n\n    - Exercise 2.41: eight-queens puzzle\n\n###### Example: A Picture Language\n\n##### Symbolic Data\n\n###### Quotation\n\n- `'a` returns a symbol: `a`\n\n- `'(a b)` evaluates to the list of symbol: `(a b)`\n\n- Extra: `` `( ) `` quotes a list where only specific members are evaluated (\"quasiquote\"). `,` specifies the evaluated number in such a list.\n    - Example: ``(let ((a 1)) `(a ,a))`` evals to `(a 1)`.\n\n- `(eq? a b)` returns whether symbol a and b are the same.\n\n###### Example: Symbolic Differentiation\n\n###### Example: Representing Sets\n\n- **Sets** are defined by operations on them, i.e. the interface of Set class.\n    - `(adjoin-set elem set)`\n    - `(element-of-set? elem set)`\n    - `(intersection-set set1 set2)`\n    - `(union-set set1 set2)`\n\n- Underlying implementation can vary:\n    - unordered lists\n    - ordered lists\n    - binary trees\n\n###### Example: Huffman Encoding Trees\n\n- prefix code: no complete code (a sequence of bits) is an prefix of another code\n    - code automatically get segmented: we can immediately obtain a code when its last bit is received\n    - no need to look forward, because it is the only legal way to decode the symbols\n\n~~~ scheme\n(define sorted-codes\n  (fastsort\n    (huffman-encode\n                '((a 8) (b 3) (c 4)\n                  (d 1) (e 1) (f 1)\n                  (g 1) (h 1) (i 9)\n                  ))\n    (sort-by (lambda (x) (- (caddr x))))))\n(map display-code sorted-codes)\n; symbol = i      count = 9       code = (0 0)\n; symbol = a      count = 8       code = (0 1)\n; symbol = c      count = 4       code = (0 1 0)\n; symbol = b      count = 3       code = (0 1 1)\n; symbol = d      count = 1       code = (1 1 1 1)\n; symbol = e      count = 1       code = (1 1 1 0)\n; symbol = h      count = 1       code = (0 1 1 1)\n; symbol = f      count = 1       code = (0 1 1 0 1)\n; symbol = g      count = 1       code = (0 1 1 0 0)\n~~~\n"},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["2014-05-19","sicp-chapter-2"]},"buildId":"fTNX2Bow0hdE_-yA1j7ND","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["script",{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=UA-39627402-1"}],["script",{"dangerouslySetInnerHTML":{"__html":"\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'UA-39627402-1', {\n              page_path: window.location.pathname,\n            });\n          "}}],["title",{"children":"Note for SICP Chapter 2"}],["meta",{"httpEquiv":"X-UA-Compatible","content":"IE=edge"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1,maximum-scale=1.5,minimum-scale=1"}],["link",{"rel":"canonical","href":"https://jokester.github.io/posts/2014-05-19/sicp-chapter-2"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-555defa4e62ba07d4446.js"></script><script src="/_next/static/chunks/main-d42d109db6976c01a5e9.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/commons.2a955b2cc4cd676398e3.js" async=""></script><script src="/_next/static/chunks/pages/_app-7c12fd0ca2279e9deba3.js" async=""></script><script src="/_next/static/chunks/framework.e6a38dee2f8f3a7cf1e7.js" async=""></script><script src="/_next/static/chunks/b7536e739236ba09df46895b208080d021a349b5.79dc8a8b4f0d930fbecb.js" async=""></script><script src="/_next/static/chunks/b52a6c8fe9dfc388856b15614b0f9ba4172af7a6.1c0a2366dab843a4556e.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-1862802d0a4a1972e3d1.js" async=""></script><script src="/_next/static/fTNX2Bow0hdE_-yA1j7ND/_buildManifest.js" async=""></script><script src="/_next/static/fTNX2Bow0hdE_-yA1j7ND/_ssgManifest.js" async=""></script></body></html>